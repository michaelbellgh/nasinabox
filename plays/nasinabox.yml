---
 - name: Configure NAS (implementation stage)
   gather_facts: false
   hosts: nas
   become: yes
   tasks:


    - name: Load VM variables
      include_vars:
        file: ../data/vars/vm.yml
        name: vm_vars

    - name: Ignore host key on first run
      set_fact:
        ansible_ssh_extra_args: '-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

    - name: Re-acquire facts
      setup:
   
    - name: Make required host directories
      file:
        path: "{{ item }}"
        state: directory
        mode: '0744'
      with_items:
       - "/home/docker/docker_data/traefik/"
       - "/var/www/ssl"
       - "/home/docker/docker_data/jackett/config/Jackett/"

    - name: Set system settings
      lineinfile:
        path: "{{ item.path }}"
        line: "{{ item.line }}"
      become: yes
      with_items:
       - { path: "/etc/gai.conf", line: "precedence ::ffff:0:0/96  100" }
       - { path: "/etc/sysctl.conf", line: "net.core.rmem_max = 4194304" }
       - { path: "/etc/sysctl.conf", line: "net.core.wmem_max = 1048576" }
       - { path: "/etc/sysctl.conf", line: "fs.file-max = 10000000" }
       - { path: "/etc/security/limits.conf", line: "root   soft    nofile    10000000"}
       - { path: "/etc/security/limits.conf", line: "root   hard    nofile    10000000"}
       - { path: "/etc/sysctl.conf", line: "net.ipv6.conf.all.disable_ipv6 = 1"}
       - { path: "/etc/sysctl.conf", line: "net.ipv6.conf.default.disable_ipv6 = 1"}
       - { path: "/etc/sysctl.conf", line: "net.ipv6.conf.lo.disable_ipv6 = 1"}
      register: set_system_settings
    
    - name: Set system settings (apply)
      command: "sysctl --system"
      when: set_system_settings.changed
    

    - name: Upgrade packages and distro
      apt:
        update_cache: yes
        upgrade: full
        state: fixed
      become: yes


    - name: GPG Key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker APT repository
      apt_repository:
        repo: deb https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable

    - name: Install additional packages
      apt:
        update_cache: yes
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg-agent
          - software-properties-common
          - docker-ce
          - docker-ce-cli
          - unzip
          - containerd.io
          - python3-pip
          - zip
          - avahi-daemon
          - unattended-upgrades
          - parted
        state: present
      become: yes

    - name: Upgrade pip for python3
      pip:
        name:
          - pip
          - docker-py
        executable: "/usr/bin/pip3"

    - name: create root key
      openssl_privatekey:
        path: /tmp/root.pem
      register: root_key

    - name: create the root CSR
      openssl_csr:
        path: /tmp/root.csr
        privatekey_path: "{{ root_key.filename }}"
        common_name: "nasinabox"
      register: root_csr
      when: root_key.changed

    - name: sign the root CSR
      openssl_certificate:
        path: /tmp/root.crt
        csr_path: "{{ root_csr.filename }}"
        privatekey_path: "{{ root_key.filename }}"
        provider: selfsigned
      register: root_crt
      when: root_key.changed

    - name: Create Web CA key
      openssl_privatekey:
        path: /tmp/webca.pem
      register: webca_key
      when: root_key.changed

    - name: Create webca CSR
      openssl_csr:
        path: /tmp/webca.csr
        privatekey_path: "{{ root_key.filename }}"
        common_name: "{{ vm_vars.vminfo.hostname }}.local"
        subject_alt_name: "DNS:{{ vm_vars.vminfo.hostname }}.local"
      register: webca_csr
      when: root_key.changed

    - name: sign the webca CSR
      openssl_certificate:
        path: /tmp/webca.crt
        csr_path: "{{ webca_csr.filename }}"
        privatekey_path: "{{ webca_key.filename }}"
        provider: selfsigned
      register: webca_crt
      when: root_key.changed


    - name: Copy all certs
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        force: yes
        remote_src: yes
        mode: '0744'
      with_items:
       - { src: "/tmp/root.crt", dest: "/usr/local/share/ca-certificates/"}
       - { src: "/tmp/webca.crt", dest: "/usr/local/share/ca-certificates/"}
       - { src: "/tmp/webca.crt", dest: "/root/webca.crt"}
       - { src: "/tmp/webca.pem", dest: "/root/webca.pem"}
      when: root_key.changed

    - name: Update CA store
      command: update-ca-certificates
      when: root_key.changed

    - name: Copy all required pre install files
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        force: yes
      become: yes
      with_items:
       - { src: "../data/traefik/traefik.yml", dest: "/home/docker/docker_data/traefik/traefik.yml", force: yes}
       - { src: "../data/traefik/certs.yml", dest: "/home/docker/docker_data/traefik/certs.yml" , force: yes}
       - { src: "../data/homer/icons/", dest: "/home/docker/docker_data/homer/icons/", force: yes}

    - name: Set permissions for ACME
      file:
        mode: 0600
        path: "/home/docker/docker_data/traefik/acme.json"
        state: touch
    


    
    - name: Enable unattended-upgrades
      lineinfile:
        path: /etc/apt/apt.conf.d/20auto-upgrades
        regexp: "{{ item.regexp }}"
        line: "{{ item.text }}"
      with_items:
       - {'regexp': '^APT::Periodic::Update-Package-Lists: .+', 'text': 'APT::Periodic::Update-Package-Lists: "1";'}
       - {'regexp': '^APT::Periodic::Unattended-Upgrade: .+', 'text': 'APT::Periodic::Unattended-Upgrade: "1";'}
       - {'regexp': '^APT::Periodic::AutocleanInterval: .+', 'text': 'APT::Periodic::AutocleanInterval: "7";'}


    - name: create internal docker network
      community.general.docker_network:
        name: docker

    - name: Add groups
      group:
        name: media
        state: present
        gid: "1001"

    - name: Add user
      user:
        name: media
        groups:
         - media
        state: present
        uid: 1001
        shell: /bin/bash
        createhome: yes

    - name: Check if Storage exist
      stat:
        path: /dev/sdb
      register: storage_exists

    - name: Check if partition exists
      stat:
        path: /dev/sdb1
      register: partition_exists


    - name: Make partition
      parted:
        device: /dev/sdb
        number: 1
        state: present
      when: storage_exists.stat.exists|bool and not partition_exists.stat.exists|bool

    - name: Make filesystem
      filesystem:
        fstype: ext4
        dev: /dev/sdb1
      when: storage_exists.stat.exists|bool and not partition_exists.stat.exists|bool

    - name: Mount drives
      mount:
        path: "{{ item.path }}"
        src: "{{ item.src }}"
        state: present
        fstype: ext4
      with_items: 
       - { path: "/mnt/Storage", src: "/dev/sdb1"}
      when: storage_exists.stat.exists|bool and not partition_exists.stat.exists|bool

    - name: Set permissions on Storage
      file:
        path: /mnt/Storage/
        mode: '644'
        state: directory
      become: yes
      when: storage_exists.stat.exists|bool and not partition_exists.stat.exists|bool




    - name: Set permissions on Docker Data
      file:
        path: /home/docker/docker_data
        recurse: yes
        mode: '0744'
      become: yes

    - name: Delete all docker containers
      shell: "{{ item }}"
      with_items: 
       - "docker stop $(docker ps -aq)"
       - "docker rm $(docker ps -aq)"
       - "docker rmi $(docker images -q)"
      when: wipe is defined
  
    - name: Wipe all data
      file:
        path: /home/docker/docker_data
        state: absent
      when: wipe is defined

    - name: Start Deluge
      docker_container:
        name: deluge
        image: linuxserver/deluge
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.deluge.rule": "PathPrefix(`/deluge`)"
          "traefik.http.routers.deluge.entrypoints": "https"
          "traefik.http.routers.deluge.tls.certresolver": "letsencrypt"
          "traefik.http.services.deluge.loadbalancer.server.port": "8112"
          "traefik.http.routers.deluge.middlewares": "deluge-stripprefix@docker"
          "traefik.http.middlewares.deluge-stripprefix.stripprefix.prefixes": "/deluge"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        env: 
         TZ: "Australia/Melbourne"
         PUID: "1001"
         PGID: "1001"
        networks:
         - name: docker
        volumes:
        - /home/docker/docker_data/deluge/config:/config
        - /mnt/Storage/Downloads:/downloads
        - /mnt/Storage/Downloads/watch:/watch
        - /mnt/Storage/Downloads/incomplete:/incomplete
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_deluge

    - name: Start plex
      docker_container:
        name: plex
        image: linuxserver/plex
        env: 
         VERSION: latest
         PUID: "1001"
         PGID: "1001"
        network_mode: host
        volumes:
        - /home/docker/docker_data/plex/config:/config
        - /mnt/Storage/Movies:/movies
        - /mnt/Storage/TV:/tv
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
      register: docker_plex

    - name: Start jackett
      docker_container:
        name: jackett
        image: linuxserver/jackett
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.jackett.rule": "PathPrefix(`/jackett`)"
          "traefik.http.routers.jackett.entrypoints": "https"
          "traefik.http.routers.jackett.tls.certresolver": "letsencrypt"
          "traefik.http.services.jackett.loadbalancer.server.port": "9117"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        env: 
         TZ: Australia/Melbourne
         AUTO_UPDATE: "true"
         PUID: "1001"
         PGID: "1001"
        networks:
        - name: docker
        volumes:
        - /home/docker/docker_data/jackett/config:/config
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_jackett

    - name: Start lidarr
      docker_container:
        name: lidarr
        image: linuxserver/lidarr
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.lidarr.rule": "PathPrefix(`/lidarr`)"
          "traefik.http.routers.lidarr.entrypoints": "https"
          "traefik.http.routers.lidarr.tls.certresolver": "letsencrypt"
          "traefik.http.services.lidarr.loadbalancer.server.port": "8686"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["jackett", "deluge"]
        volumes:
        - /home/docker/docker_data/lidarr/config:/config
        - /mnt/Storage/Music:/music
        - /mnt/Storage/Downloads:/downloads
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_lidarr

    - name: Start radarr
      docker_container:
        name: radarr
        image: linuxserver/radarr:nightly
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.radarr.rule": "PathPrefix(`/radarr`)"
          "traefik.http.routers.radarr.entrypoints": "https"
          "traefik.http.routers.radarr.tls.certresolver": "letsencrypt"
          "traefik.http.services.radarr.loadbalancer.server.port": "7878"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        networks:
        - name: "docker"
          links: ["deluge", "jackett"]
        volumes:
        - /home/docker/docker_data/radarr/config:/config
        - /mnt/Storage/Movies:/movies
        - /mnt/Storage/Downloads:/downloads
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_radarr

    - name: Start sonarr
      docker_container:
        name: sonarr
        image: linuxserver/sonarr:latest
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.sonarr.rule": "PathPrefix(`/sonarr`)"
          "traefik.http.routers.sonarr.entrypoints": "https"
          "traefik.http.routers.sonarr.tls.certresolver": "letsencrypt"
          "traefik.http.services.sonarr.loadbalancer.server.port": "8989"
        networks:
        - name: "docker"
          links: ["jackett", "deluge"]
        volumes:
        - /home/docker/docker_data/sonarr/config:/config
        - /mnt/Storage/TV:/tv
        - /mnt/Storage/Downloads:/downloads
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_sonarr

    - name: Start ombi
      docker_container:
        name: ombi
        image: linuxserver/ombi
        env: 
         TZ: Australia/Melbourne
         BASE_URL: "/ombi"
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.ombi.rule": "PathPrefix(`/ombi`)"
          "traefik.http.routers.ombi.entrypoints": "https"
          "traefik.http.routers.ombi.tls.certresolver": "letsencrypt"
          "traefik.http.services.ombi.loadbalancer.server.port": "3579"
          "traefik.http.middlewares.protoheader.headers.customrequestheaders.X-Forwarded-Proto": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["sonarr", "radarr", "ombi"]
        volumes:
        - /home/docker/docker_data/ombi/config:/config
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_ombi


    - name: Start bazarr
      docker_container:
        name: bazarr
        image: linuxserver/bazarr
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        published_ports: ["6767:6767"]
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.bazarr.rule": "PathPrefix(`/bazarr`)"
          "traefik.http.routers.bazarr.entrypoints": "https"
          "traefik.http.routers.bazarr.tls.certresolver": "letsencrypt"
          "traefik.http.services.bazarr.loadbalancer.server.port": "6767"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["sonarr", "radarr"]
        volumes:
        - /home/docker/docker_data/bazarr/config:/config
        - /mnt/Storage/Movies:/movies
        - /mnt/Storage/TV:/tv
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_bazarr

    - name: Start readarr
      docker_container:
        name: readarr
        image: hotio/readarr:testing
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.readarr.rule": "PathPrefix(`/readarr`)"
          "traefik.http.routers.readarr.entrypoints": "https"
          "traefik.http.routers.readarr.tls.certresolver": "letsencrypt"
          "traefik.http.services.readarr.loadbalancer.server.port": "8787"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        volumes:
        - "/home/docker/docker_data/readarr:/config"
        - "/mnt/Storage/Books:/books"
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        networks:
        - name: "docker"
          links: ["jackett", "deluge"]
        purge_networks: yes
      register: docker_readarr

    - name: Start Homer
      docker_container:
        name: homer
        image: b4bz/homer:latest
        env:
          PUID: "1001"
          PGID: "1001"
          TZ: Australia/Melbourne
        volumes:
        - /home/docker/docker_data/homer:/www/assets
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.homer.rule": "PathPrefix(`/`)"
          "traefik.http.routers.homer.tls": "true"
          "traefik.http.routers.homer.entrypoints": "https"
          "traefik.http.services.homer.loadbalancer.server.port": "8080"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"  
        networks:
         - name: docker
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_homer


    - name: Start samba
      docker_container:
        name: samba
        image: dperson/samba
        env: 
         TZ: Australia/Melbourne
         USERID: "1001"
         GROUPID: "1001"
         NMBD: "yes"
        network_mode: host
        volumes:
        - /mnt/Storage/Movies:/movies
        - /mnt/Storage/TV:/tv
        - /mnt/Storage/Music:/music
        - /mnt/Storage/Downloads:/downloads
        - /mnt/Storage/Share:/share
        - /mnt/Storage/files:/files
        command:
         - "-s TV;/tv;yes;yes;yes;all;none"
         - "-s Movies;/movies;yes;yes;yes;all;none"
         - "-s Downloads;/downloads;yes;yes;yes;all;none"
         - "-s Music;/music;yes;no;yes;all;none"
         - "-s Share;/share;yes;no;yes;all;none"
         - "-s Files;/files;yes;no;yes;all;none"
        restart_policy: unless-stopped
        purge_networks: yes




    - name: Run traefik
      docker_container:
        name: traefik
        recreate: "{{ 'yes' if docker_bazarr.changed or docker_deluge.changed or docker_jackett.changed or docker_readarr.changed or docker_lidarr.changed or docker_ombi.changed or docker_radarr.changed or docker_sonarr.changed | default(no) else omit }}"
        labels: 
          "traefik.enable": "true"
          "traefik.http.routers.api.rule": "PathPrefix(`/traefik`)"
          "traefik.http.routers.api.entrypoints": "https,http"
          "traefik.http.routers.api.service": "dashboard@internal"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "https"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "http"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        image: "traefik:latest"
        network_mode: host
        restart_policy: unless-stopped
        volumes:
        - "/var/run/docker.sock:/var/run/docker.sock"
        - "/var/www/ssl/:/ssl"
        - "/home/docker/docker_data/traefik/traefik.yml:/traefik.yml"
        - "/home/docker/docker_data/traefik/certs.yml:/certs.yml"
        - "/home/docker/docker_data/traefik/acme.json:/acme.json"
        - "/root/webca.crt:/webca.crt"
        - "/root/webca.pem:/webca.pem"
        purge_networks: yes
      tags: 
      - "traefik"

    - name: Set permissions (mode)
      file:
        path: "/mnt/"
        recurse: yes
        mode: '777'
      become: yes


    - name: Stop all docker containers
      shell: "docker kill $(docker ps -q)"
    
    - name: Copy Indexers zip
      copy:
        src: ../data/jackett/Indexers.zip
        dest: /home/docker/docker_data/jackett/config/Jackett/Indexers.zip


    - name: Unarchive Indexers.zip
      unarchive:
        src: /home/docker/docker_data/jackett/config/Jackett/Indexers.zip
        remote_src: yes
        dest: /home/docker/docker_data/jackett/config/Jackett/

    - name: Check if deluge web.conf is missing
      stat: 
        path: /home/docker/docker_data/deluge/config/web.conf
      register: deluge_web_conf

    
    - name: Set deluge webconf fact
      set_fact:
        deluge_web_conf_contents: '
        {
        "file": 2,
        "format": 1
        }{
        "base" : "/deluge",
        "cert": "ssl/daemon.cert",
        "default_daemon": "",
        "enabled_plugins": ["Label", "Execute"],
        "first_login": false,
        "https": false,
        "interface": "0.0.0.0",
        "language": "",
        "pkey": "ssl/daemon.pkey",
        "port": 8112,
        "pwd_salt": "c26ab3bbd8b137f99cd83c2c1c0963bcc1a35cad",
        "pwd_sha1": "2ce1a410bcdcc53064129b6d950f2e9fee4edc1e",
        "session_timeout": 3600,
        "show_session_speed": false,
        "show_sidebar": true,
        "sidebar_multiple_filters": true,
        "sidebar_show_zero": false,
        "theme": "gray"}'
      when: not deluge_web_conf.stat.exists

    - name: Set deluge webconf
      copy:
        dest: "/home/docker/docker_data/deluge/config/web.conf"
        content: "{{ deluge_web_conf_contents }}"
      become: yes
      when: not deluge_web_conf.stat.exists


    - name: Set other app parameters
      replace:
        regexp: "{{ item.regexp }}"
        replace: "{{ item.line }}"
        path: "{{ item.path }}"
      with_items:
       - { regexp: '"/root/Downloads"', line: '"/downloads"', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"enabled_plugins\"[:\s]+\[.*]', line: '"enabled_plugins": ["Label", "Execute"]', path: "/home/docker/docker_data/deluge/config/core.conf"}
      when: not deluge_web_conf.stat.exists
      

    - name: Start deluge
      docker_container:
        name: deluge
        state: started
        restart: yes
      become: yes
      when: not deluge_web_conf.stat.exists



    - name: Set URL base on configs
      replace:
        regexp: "{{ item.regexp }}"
        replace: "{{ item.line }}"
        path: "{{ item.path }}"
      with_items:
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/lidarr</UrlBase>", path: "/home/docker/docker_data/lidarr/config/config.xml"}
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/sonarr</UrlBase>", path: "/home/docker/docker_data/sonarr/config/config.xml"}
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/radarr</UrlBase>", path: "/home/docker/docker_data/radarr/config/config.xml"}
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/readarr</UrlBase>", path: "/home/docker/docker_data/readarr/config.xml"}
       - { regexp: 'base_url.+\=(.+)*', line: "base_url = /bazarr", path: "/home/docker/docker_data/bazarr/config/config/config.ini"}
       - { regexp: '"BasePathOverride"(\s+)?\:\s+[^,\r\n]+', line: '"BasePathOverride": "/jackett"', path: "/home/docker/docker_data/jackett/config/Jackett/ServerConfig.json"}
       - { regexp: '"base":\s+".+"', line: '  "base" : "/deluge"', path: "/home/docker/docker_data/deluge/config/web.conf"}
      register: url_base_output



    - name: Set API Key to single key
      replace:
        regexp: "{{ item.regexp }}"
        path: "{{ item.path }}"
        replace: "{{ item.line }}"
      with_items:
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/lidarr/config/config.xml"}
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/sonarr/config/config.xml"}
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/radarr/config/config.xml"}
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/readarr/config.xml"}
        - { regexp: 'apikey[\s\=]*[a-zA-Z0-9]*', line: "apikey = {{ vm_vars.api_key }}", path: "/home/docker/docker_data/bazarr/config/config/config.ini"}
        - { regexp: '"APIKey"\s*\:\s*"[a-zA-Z0-9]*"', line: '"APIKey" : "{{ vm_vars.api_key }}"', path: "/home/docker/docker_data/jackett/config/Jackett/ServerConfig.json"}
      register: api_change_output

    - name: Generate Deluge web.conf
      set_fact:
        deluge_web_conf_content: '
        {
    "file": 2,
    "format": 1
}{
      "base" : "/deluge",
    "cert": "ssl/daemon.cert",
    "default_daemon": "",
    "enabled_plugins": [],
    "first_login": false,
    "https": false,
    "interface": "0.0.0.0",
    "language": "",
    "pkey": "ssl/daemon.pkey",
    "port": 8112,
    "pwd_salt": "c26ab3bbd8b137f99cd83c2c1c0963bcc1a35cad",
    "pwd_sha1": "2ce1a410bcdcc53064129b6d950f2e9fee4edc1e",
    "session_timeout": 3600,
    "show_session_speed": false,
    "show_sidebar": true,
    "sidebar_multiple_filters": true,
    "sidebar_show_zero": false,
    "theme": "gray"
}'
      when: not deluge_web_conf.stat.exists

 
    - name: Restart deluge, allow web.conf generation
      copy:
        dest: /home/docker/docker_data/deluge/config/web.conf
        content: "{{ deluge_web_conf_content }}"
        
      become: yes
      when: not deluge_web_conf.stat.exists

    - name: Restart certain containers if containers API, URL base or other params have changed
      docker_container:
        name: "{{ item }}"
        state: started
        restart: yes
      with_items: ["lidarr", "sonarr", "radarr", "bazarr", "readarr", "jackett", "deluge"]
      when: url_base_output.changed or api_change_output.changed
    

    - name: Template homer dashboard
      template:
        src: ../data/homer/homer.j2
        dest: /home/docker/docker_data/homer/config.yml
        mode: '0777'

    - name: Set homer permissions
      file:
        path: /home/docker/docker_data/homer/
        mode: '0777'
        recurse: yes

    - name: Set permissions (dirs)
      file:
        path: "{{ item.path }}"
        recurse: yes
        owner: "{{ item.owner }}"
        group: "{{ item.group }}"
        mode: "{{ item.mode }}"
      become: yes
      with_items:
       - { path: "/mnt/Storage", owner: media, group: media, mode: '0744' }
       - { path: "/home/docker/docker_data/", owner: media, group: media, mode: '0744' }
       - { path: "/home/docker/docker_data/homer", owner: media, group: media, mode: '0777'}
      register: final_permissions_dir

    - name: Set permissions (files)
      file:
        path: "{{ item.path }}"
        owner: "{{ item.owner }}"
        group: "{{ item.group }}"
        mode: "{{ item.mode }}"
      become: yes
      with_items:
       - { path: "/home/docker/docker_data/traefik/acme.json", owner: media, group: media, mode: '0600' }
      register: final_permissions_files


    - name: Start docker containers
      shell: "docker start $(docker ps -a -q)"

    - name: Wait for return code
      uri:
        url: "https://{{ ansible_default_ipv4.address }}:443/{{ item }}"
        status_code: 200
        validate_certs: false
      register: result
      until: result.status == 200
      retries: 60
      delay: 1
      with_items:
       - "sonarr"
       - "lidarr"
       - "radarr"


    - name: Run configurator (with opensubtitles support)
      command: "python3 configure_apps.py -i {{ ansible_default_ipv4.address }} -p 443 -a {{ vm_vars.api_key }} --open-subtitles-username {{ vm_vars.nas.open_subtitles_username }} --open-subtitles-password {{ vm_vars.nas.open_subtitles_password }}"
      delegate_to: localhost
      args:
        chdir: scripts
      become: no
      register: configurator_w_support
      when: vm_vars.nas.open_subtitles_username is defined and vm_vars.nas.open_subtitles_password is defined
      failed_when: "'success' not in configurator_w_support.stdout"
      

    - name: Run configurator
      command: "python3 configure_apps.py -i {{ ansible_default_ipv4.address }} -p 443 -a {{ vm_vars.api_key }} {{ '--open-subtitles-username' vm_vars.nas.open_subtitles_username if vm_vars.nas.open_subtitles_username is defined }}"
      delegate_to: localhost
      args:
        chdir: scripts
      become: no
      register: configurator
      when: "configurator_w_support is not defined"
      failed_when: "'success' not in configurator.stdout"

    - name: Enable services
      systemd:
        name: "{{ item }}"
        enabled: yes
        state: started
      with_items:
       - "avahi-daemon"


    - name: Restart all containers
      shell: docker restart $(docker ps -q)
      when: restart is defined




     