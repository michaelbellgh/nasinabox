---
 - name: Configure NAS (implementation stage)
   gather_facts: false
   hosts: nas
   become: yes
   tasks:


    - name: Load VM variables
      include_vars:
        file: ../data/vars/vm.yml
        name: vm_vars

    - name: Ignore host key on first run
      set_fact:
        ansible_ssh_extra_args: '-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

    - name: Re-acquire facts
      setup:
   
    - name: Make required host directories
      file:
        path: "{{ item }}"
        state: directory
        mode: '0744'
      with_items:
       - "/home/docker/docker_data/traefik/"
       - "/var/www/ssl"
       - "/home/docker/docker_data/jackett/config/Jackett/"

    - name: Set system settings
      lineinfile:
        path: "{{ item.path }}"
        line: "{{ item.line }}"
      become: yes
      with_items:
       - { path: "/etc/gai.conf", line: "precedence ::ffff:0:0/96  100" }
       - { path: "/etc/sysctl.conf", line: "net.core.rmem_max = 4194304" }
       - { path: "/etc/sysctl.conf", line: "net.core.wmem_max = 1048576" }
       - { path: "/etc/sysctl.conf", line: "fs.file-max = 10000000" }
       - { path: "/etc/security/limits.conf", line: "root   soft    nofile    10000000"}
       - { path: "/etc/security/limits.conf", line: "root   hard    nofile    10000000"}
       - { path: "/etc/sysctl.conf", line: "net.ipv6.conf.all.disable_ipv6 = 1"}
       - { path: "/etc/sysctl.conf", line: "net.ipv6.conf.default.disable_ipv6 = 1"}
       - { path: "/etc/sysctl.conf", line: "net.ipv6.conf.lo.disable_ipv6 = 1"}
      register: set_system_settings
    
    - name: Set system settings (apply)
      command: "sysctl -p"
    

    - name: Upgrade packages and distro
      apt:
        update_cache: yes
        upgrade: full
        state: fixed
      become: yes


    - name: GPG Keys
      apt_key:
        url: "{{ item }}"
        state: present
      with_items:
       - https://download.docker.com/linux/ubuntu/gpg
       
    - name: Download keyrings
      get_url:
        url: "{{ item.url }}"
        dest: "{{ item.dest }}"
      with_items:
       - {url: "https://pkgs.tailscale.com/stable/ubuntu/focal.noarmor.gpg", dest: "/usr/share/keyrings/tailscale-archive-keyring.gpg"}
       - {url: "https://pkgs.tailscale.com/stable/ubuntu/focal.tailscale-keyring.list", dest: "/etc/apt/sources.list.d/tailscale.list"}

    - name: Add Docker APT repository
      apt_repository:
        repo: deb https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable

    - name: Install additional packages
      apt:
        update_cache: yes
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg-agent
          - software-properties-common
          - docker-ce
          - docker-ce-cli
          - unzip
          - containerd.io
          - python3-pip
          - zip
          - avahi-daemon
          - unattended-upgrades
          - parted
          - sqlite
          - open-vm-tools
          - tailscale
          - zfsutils
        state: present
      become: yes

    - name: Upgrade pip for python3
      pip:
        name:
          - pip
          - docker-py
        executable: "/usr/bin/pip3"

    - name: create root key
      openssl_privatekey:
        path: /tmp/root.pem
      register: root_key

    - name: create the root CSR
      openssl_csr:
        path: /tmp/root.csr
        privatekey_path: "{{ root_key.filename }}"
        common_name: "nasinabox"
      register: root_csr
      when: root_key.changed

    - name: sign the root CSR
      openssl_certificate:
        path: /tmp/root.crt
        csr_path: "{{ root_csr.filename }}"
        privatekey_path: "{{ root_key.filename }}"
        provider: selfsigned
      register: root_crt
      when: root_key.changed

    - name: Create Web CA key
      openssl_privatekey:
        path: /tmp/webca.pem
      register: webca_key
      when: root_key.changed

    - name: Create webca CSR
      openssl_csr:
        path: /tmp/webca.csr
        privatekey_path: "{{ root_key.filename }}"
        common_name: "{{ vm_vars.vminfo.hostname }}.local"
        subject_alt_name: "DNS:{{ vm_vars.vminfo.hostname }}.local"
      register: webca_csr
      when: root_key.changed

    - name: sign the webca CSR
      openssl_certificate:
        path: /tmp/webca.crt
        csr_path: "{{ webca_csr.filename }}"
        privatekey_path: "{{ webca_key.filename }}"
        provider: selfsigned
      register: webca_crt
      when: root_key.changed


    - name: Copy all certs
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        force: yes
        remote_src: yes
        mode: '0744'
      with_items:
       - { src: "/tmp/root.crt", dest: "/usr/local/share/ca-certificates/"}
       - { src: "/tmp/webca.crt", dest: "/usr/local/share/ca-certificates/"}
       - { src: "/tmp/webca.crt", dest: "/root/webca.crt"}
       - { src: "/tmp/webca.pem", dest: "/root/webca.pem"}
      when: root_key.changed

    - name: Set Traefik default port (if ssl)
      set_fact: 
        traefik_default_port: "443"
        traefik_default_scheme: "https"
      when: vm_vars.nas.default_to_ssl is defined and vm_vars.nas.default_to_ssl

    - name: Set Traefik default port (if not ssl)
      set_fact:
        traefik_default_port: "80"
        traefik_default_scheme: "http"
      when: vm_vars.nas.default_to_ssl is not defined or (vm_vars.nas.default_to_ssl is defined and not vm_vars.nas.default_to_ssl)
        

    - name: Update CA store
      command: update-ca-certificates
      when: root_key.changed

    - name: Copy all required pre install files
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        force: yes
      become: yes
      with_items:
       - { src: "../data/traefik/traefik.yml", dest: "/home/docker/docker_data/traefik/traefik.yml", force: yes}
       - { src: "../data/traefik/certs.yml", dest: "/home/docker/docker_data/traefik/certs.yml" , force: yes}
       - { src: "../data/homer/icons/", dest: "/home/docker/docker_data/homer/icons/", force: yes}

    - name: Set permissions for ACME
      file:
        mode: 0600
        path: "/home/docker/docker_data/traefik/acme.json"
        state: touch
    


    
    - name: Enable unattended-upgrades
      lineinfile:
        path: /etc/apt/apt.conf.d/20auto-upgrades
        regexp: "{{ item.regexp }}"
        line: "{{ item.text }}"
      with_items:
       - {'regexp': '^APT::Periodic::Update-Package-Lists: .+', 'text': 'APT::Periodic::Update-Package-Lists: "1";'}
       - {'regexp': '^APT::Periodic::Unattended-Upgrade: .+', 'text': 'APT::Periodic::Unattended-Upgrade: "1";'}
       - {'regexp': '^APT::Periodic::AutocleanInterval: .+', 'text': 'APT::Periodic::AutocleanInterval: "7";'}


    - name: create internal docker network
      community.general.docker_network:
        name: docker

    - name: Add groups
      group:
        name: media
        state: present
        gid: "1001"

    - name: Add user
      user:
        name: media
        groups:
         - media
        state: present
        uid: 1001
        shell: /bin/bash
        createhome: yes

    - name: Check if Storage exist
      stat:
        path: /dev/sdb
      register: storage_exists
      when: vm_vars.zfs_drives |length == 0

    - name: Check if partition exists
      stat:
        path: /dev/sdb1
      register: partition_exists
      when: vm_vars.zfs_drives |length == 0


    - name: Make partition
      parted:
        device: /dev/sdb
        number: 1
        state: present
      when: "vm_vars.zfs_drives |length == 0 and storage_exists.stat.exists|bool and not partition_exists.stat.exists|bool"
      

    - name: Make filesystem
      filesystem:
        fstype: ext4
        dev: /dev/sdb1
      when:  vm_vars.zfs_drives |length == 0 and storage_exists.stat.exists|bool and not partition_exists.stat.exists|bool

    - name: Mount drives
      mount:
        path: "{{ item.path }}"
        src: "{{ item.src }}"
        state: present
        fstype: ext4
      with_items: 
       - { path: "{{ vm_vars.nas.storage_path }}", src: "/dev/sdb1"}
      when: vm_vars.zfs_drives |length == 0 and storage_exists.stat.exists|bool

    - name: Get zpool info
      command: "zfs list"
      register: zfacts
      when: vm_vars.zfs_drives |length > 0
      
    - name: Try import NAS pool
      command: "zpool import NAS -f"
      when: '"{{ vm_vars.nas.storage_path }}" not in zfacts.stdout'
      register: try_import
      ignore_errors: yes
                                                                                     
    - name: Get ZFS pools
      command: "zfs list"
      register: zfs_pools
      when: vm_vars.zfs_drives |length > 0               
                                                                                     
    - name: Make ZFS pool
      command: "zpool create NAS {{ vm_vars.zfs_type }} {{ vm_vars.zfs_drives | join(' ') }}"
      when: vm_vars.zfs_drives |length > 0 and 'NAS' not in zfacts.stdout                                     

    - name: Make ZFS pool (force)
      command: "zpool create NAS raidz {{ zfs_list }} -f"
      when: '"NAS" not in zfs_pools.stdout and force is defined'


    - name: Mount ZFS pool
      command: "zfs set mountpoint={{ vm_vars.nas.storage_path }} NAS"
      when: vm_vars.zfs_drives is defined and vm_vars.zfs_drives |length > 0

    - name: Make mount point
      file: 
        path: "{{ vm_vars.nas.storage_path }}"
        state: directory
      when: vm_vars.zfs_drives |length == 0

    - name: Fallback to fix mount module issue
      command: "mount {{ item }}"
      with_items: 
       - "{{ vm_vars.nas.storage_path }}"
      ignore_errors: yes
      when: vm_vars.zfs_drives |length == 0

    - name: Set permissions on Storage
      file:
        path: "{{ vm_vars.nas.storage_path }}"
        mode: '644'
        state: directory
      become: yes


    - name: Get homer theme
      ansible.builtin.git:
        repo: "https://github.com/walkxcode/homer-theme"
        dest: /tmp/Homer-Theme
        force: yes


    - name: Copy WalkXCode-Homer theme css
      copy:
        src: "{{ item.src }}"
        dest: "{{ item.dest }}"
        remote_src: yes
        force: yes
      with_items:
       - {src: /tmp/Homer-Theme/assets/custom.css, dest: /home/docker/docker_data/homer/walkxcode-homer.css }
       - {src: /tmp/Homer-Theme/assets/wallpaper.jpeg, dest: /home/docker/docker_data/homer/wallpaper.jpeg }
       - {src: /tmp/Homer-Theme/assets/wallpaper-light.jpeg, dest: /home/docker/docker_data/homer/wallpaper-light.jpeg }
       - {src: /tmp/Homer-Theme/assets/manifest.json, dest: /home/docker/docker_data/homer/manifest.json }
       - {src: /tmp/Homer-Theme/assets/fonts, dest: /home/docker/docker_data/homer/fonts}

    - name: Set permissions on Docker Data
      file:
        path: /home/docker/docker_data
        recurse: yes
        mode: '0744'
      become: yes

    - name: Delete all docker containers
      shell: "{{ item }}"
      with_items: 
       - "docker stop $(docker ps -aq)"
       - "docker rm $(docker ps -aq)"
       - "docker rmi $(docker images -q)"
      when: wipe is defined
  
    - name: Wipe all data
      file:
        path: /home/docker/docker_data
        state: absent
      when: wipe is defined

    - name: Start Deluge
      docker_container:
        name: deluge
        image: linuxserver/deluge:2.1.1-r3-ls179
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.deluge.rule": "PathPrefix(`/deluge`)"
          "traefik.http.routers.deluge.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.routers.deluge.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.services.deluge.loadbalancer.server.port": "8112"
          "traefik.http.routers.deluge.middlewares": "deluge-stripprefix@docker"
          "traefik.http.middlewares.deluge-stripprefix.stripprefix.prefixes": "/deluge"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        env: 
         TZ: "Australia/Melbourne"
         PUID: "1001"
         PGID: "1001"
        networks:
         - name: docker
        volumes:
        - /home/docker/docker_data/deluge/config:/config
        - "{{ vm_vars.nas.storage_path }}Downloads:/downloads"
        - "{{ vm_vars.nas.storage_path }}Downloads/watch:/watch"
        - "{{ vm_vars.nas.storage_path }}Downloads/incomplete:/incomplete"
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_deluge

    - name: Start plex
      docker_container:
        name: plex
        image: linuxserver/plex
        env: 
         VERSION: latest
         PUID: "1001"
         PGID: "1001"
        network_mode: host
        volumes:
        - /home/docker/docker_data/plex/config:/config
        - "{{ vm_vars.nas.storage_path }}Movies:/movies"
        - "{{ vm_vars.nas.storage_path }}TV:/tv"
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
      register: docker_plex

    - name: Start jackett
      docker_container:
        name: jackett
        image: linuxserver/jackett
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.jackett.rule": "PathPrefix(`/jackett`)"
          "traefik.http.routers.jackett.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.jackett.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.services.jackett.loadbalancer.server.port": "9117"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        env: 
         TZ: Australia/Melbourne
         AUTO_UPDATE: "true"
         PUID: "1001"
         PGID: "1001"
        networks:
        - name: docker
        volumes:
        - /home/docker/docker_data/jackett/config:/config
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_jackett

    - name: Start lidarr
      docker_container:
        name: lidarr
        image: linuxserver/lidarr
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.lidarr.rule": "PathPrefix(`/lidarr`)"
          "traefik.http.routers.lidarr.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.lidarr.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.services.lidarr.loadbalancer.server.port": "8686"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["jackett", "deluge"]
        volumes:
        - /home/docker/docker_data/lidarr/config:/config
        - "{{ vm_vars.nas.storage_path }}Music:/music"
        - "{{ vm_vars.nas.storage_path }}Downloads:/downloads"
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_lidarr

    - name: Start radarr
      docker_container:
        name: radarr
        image: linuxserver/radarr:nightly
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.radarr.rule": "PathPrefix(`/radarr`)"
          "traefik.http.routers.radarr.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.services.radarr.loadbalancer.server.port": "7878"
          "traefik.http.routers.radarr.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        networks:
        - name: "docker"
          links: ["deluge", "jackett"]
        volumes:
        - /home/docker/docker_data/radarr/config:/config
        - "{{ vm_vars.nas.storage_path }}Movies:/movies"
        - "{{ vm_vars.nas.storage_path }}Downloads:/downloads"
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_radarr

    - name: Start sonarr
      docker_container:
        name: sonarr
        image: linuxserver/sonarr:latest
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.sonarr.rule": "PathPrefix(`/sonarr`)"
          "traefik.http.routers.sonarr.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.sonarr.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.services.sonarr.loadbalancer.server.port": "8989"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["jackett", "deluge"]
        volumes:
        - /home/docker/docker_data/sonarr/config:/config
        - "{{ vm_vars.nas.storage_path }}TV:/tv"
        - "{{ vm_vars.nas.storage_path }}Downloads:/downloads"
        - /var/www/ssl/:/ssl
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_sonarr

    - name: Start ombi
      docker_container:
        name: ombi
        image: linuxserver/ombi
        env: 
         TZ: Australia/Melbourne
         BASE_URL: "/ombi"
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.ombi.rule": "PathPrefix(`/ombi`)"
          "traefik.http.routers.ombi.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.services.ombi.loadbalancer.server.port": "3579"
          "traefik.http.routers.ombi.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.middlewares.protoheader.headers.customrequestheaders.X-Forwarded-Proto": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["sonarr", "radarr", "ombi"]
        volumes:
        - /home/docker/docker_data/ombi/config:/config
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_ombi


    - name: Start bazarr
      docker_container:
        name: bazarr
        image: linuxserver/bazarr
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        published_ports: ["6767:6767"]
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.bazarr.rule": "PathPrefix(`/bazarr`)"
          "traefik.http.routers.bazarr.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.services.bazarr.loadbalancer.server.port": "6767"
          "traefik.http.routers.bazarr.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["sonarr", "radarr"]
        volumes:
        - /home/docker/docker_data/bazarr/config:/config
        - "{{ vm_vars.nas.storage_path }}Movies:/movies"
        - "{{ vm_vars.nas.storage_path }}TV:/tv"
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_bazarr


    - name: Start prowlarr
      docker_container:
        name: prowlarr
        image: lscr.io/linuxserver/prowlarr:develop
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        published_ports: ["9696:9696"]
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.prowlarr.rule": "PathPrefix(`/prowlarr`)"
          "traefik.http.routers.prowlarr.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.services.prowlarr.loadbalancer.server.port": "9696"
          "traefik.http.routers.prowlarr.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        networks:
        - name: "docker"
          links: ["sonarr", "radarr"]
        volumes:
        - /home/docker/docker_data/prowlarr/config:/config
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_prowlarr

    - name: Start readarr
      docker_container:
        name: readarr
        image: hotio/readarr:testing
        env: 
         TZ: Australia/Melbourne
         PUID: "1001"
         PGID: "1001"
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.readarr.rule": "PathPrefix(`/readarr`)"
          "traefik.http.routers.readarr.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.services.readarr.loadbalancer.server.port": "8787"
          "traefik.http.routers.readarr.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        volumes:
        - "/home/docker/docker_data/readarr:/config"
        - "{{ vm_vars.nas.storage_path }}Books:/books"
        - "/var/www/ssl/:/ssl"
        restart_policy: unless-stopped
        networks:
        - name: "docker"
          links: ["jackett", "deluge"]
        purge_networks: yes
      register: docker_readarr

    - name: Start Homer
      docker_container:
        name: homer
        image: b4bz/homer:latest
        env:
          PUID: "1001"
          PGID: "1001"
          TZ: Australia/Melbourne
        volumes:
        - /home/docker/docker_data/homer:/www/assets
        labels:
          "traefik.enable": "true"
          "traefik.http.routers.homer.rule": "PathPrefix(`/`)"
          "traefik.http.routers.homer.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.services.homer.loadbalancer.server.port": "8080"
          "traefik.http.routers.homer.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"  
        networks:
         - name: docker
        restart_policy: unless-stopped
        purge_networks: yes
      register: docker_homer


    - name: Start samba
      docker_container:
        name: samba
        image: dperson/samba
        env: 
         TZ: Australia/Melbourne
         USERID: "1001"
         GROUPID: "1001"
         NMBD: "yes"
        network_mode: host
        volumes:
        - "{{ vm_vars.nas.storage_path }}Movies:/movies"
        - "{{ vm_vars.nas.storage_path }}TV:/tv"
        - "{{ vm_vars.nas.storage_path }}Music:/music"
        - "{{ vm_vars.nas.storage_path }}Downloads:/downloads"
        - "{{ vm_vars.nas.storage_path }}Share:/share"
        - "{{ vm_vars.nas.storage_path }}files:/files"
        command:
         - "-s TV;/tv;yes;yes;yes;all;none"
         - "-s Movies;/movies;yes;yes;yes;all;none"
         - "-s Downloads;/downloads;yes;yes;yes;all;none"
         - "-s Music;/music;yes;no;yes;all;none"
         - "-s Share;/share;yes;no;yes;all;none"
         - "-s Files;/files;yes;no;yes;all;none"
        command_handling: correct
        restart_policy: unless-stopped
        purge_networks: yes




    - name: Run traefik
      docker_container:
        name: traefik
        recreate: "{{ 'yes' if docker_bazarr.changed or docker_deluge.changed or docker_jackett.changed or docker_readarr.changed or docker_lidarr.changed or docker_ombi.changed or docker_radarr.changed or docker_sonarr.changed | default(no) else omit }}"
        labels: 
          "traefik.enable": "true"
          "traefik.http.routers.api.rule": "PathPrefix(`/traefik`)"
          "traefik.http.routers.api.entrypoints": "https,http"
          "traefik.http.routers.api.service": "dashboard@internal"
          "traefik.http.routers.traefik.tls": "{{ 'true' if traefik_default_scheme == 'https' else 'http'}}"
          "traefik.http.middlewares.https_redirect.redirectscheme.scheme": "{{ traefik_default_scheme }}"
          "traefik.http.middlewares.https_redirect.redirectscheme.permanent": "true"
          "traefik.http.routers.http_catchall.rule": "HostRegexp(`{any:.+}`)"
          "traefik.http.routers.http_catchall.entrypoints": "{{ traefik_default_scheme }}"
          "traefik.http.routers.http_catchall.middlewares": "https_redirect"
        image: "traefik:latest"
        network_mode: host
        restart_policy: unless-stopped
        volumes:
        - "/var/run/docker.sock:/var/run/docker.sock"
        - "/var/www/ssl/:/ssl"
        - "/home/docker/docker_data/traefik/traefik.yml:/traefik.yml"
        - "/home/docker/docker_data/traefik/certs.yml:/certs.yml"
        - "/home/docker/docker_data/traefik/acme.json:/acme.json"
        - "/root/webca.crt:/webca.crt"
        - "/root/webca.pem:/webca.pem"
        purge_networks: yes
      tags: 
      - "traefik"

    - name: Set permissions (mode)
      file:
        path: "/mnt/"
        recurse: yes
        mode: '777'
      become: yes


    - name: Stop all docker containers
      shell: "docker kill $(docker ps -q)"
    
    - name: Copy Indexers zip
      copy:
        src: ../data/jackett/Indexers.zip
        dest: /home/docker/docker_data/jackett/config/Jackett/Indexers.zip


    - name: Unarchive Indexers.zip
      unarchive:
        src: /home/docker/docker_data/jackett/config/Jackett/Indexers.zip
        remote_src: yes
        dest: /home/docker/docker_data/jackett/config/Jackett/

    - name: Check if deluge web.conf is missing
      stat: 
        path: /home/docker/docker_data/deluge/config/web.conf
      register: deluge_web_conf

    
    - name: Set deluge webconf fact
      set_fact:
        deluge_web_conf_contents: '
        {
        "file": 2,
        "format": 1
        }{
        "base" : "/deluge",
        "cert": "ssl/daemon.cert",
        "default_daemon": "",
        "enabled_plugins": ["Label", "Execute"],
        "first_login": false,
        "https": false,
        "interface": "0.0.0.0",
        "language": "",
        "pkey": "ssl/daemon.pkey",
        "port": 8112,
        "pwd_salt": "c26ab3bbd8b137f99cd83c2c1c0963bcc1a35cad",
        "pwd_sha1": "2ce1a410bcdcc53064129b6d950f2e9fee4edc1e",
        "session_timeout": 3600,
        "show_session_speed": false,
        "show_sidebar": true,
        "sidebar_multiple_filters": true,
        "sidebar_show_zero": false,
        "theme": "gray"}'
      when: not deluge_web_conf.stat.exists

    - name: Set deluge webconf
      copy:
        dest: "/home/docker/docker_data/deluge/config/web.conf"
        content: "{{ deluge_web_conf_contents }}"
      become: yes
      when: not deluge_web_conf.stat.exists


    - name: Set other app parameters
      replace:
        regexp: "{{ item.regexp }}"
        replace: "{{ item.line }}"
        path: "{{ item.path }}"
      with_items:
       - { regexp: '"/root/Downloads"', line: '"/downloads"', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"max_connections_global\"\s*\:\s*\d+', line: '"max_connections_global": 5000', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"max_active_limit\"\s*\:\s*\d+', line: '"max_active_limit": 30', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"max_active_limit\"\s*\:\s*\d+', line: '"max_active_limit": 30', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"max_active_downloading\"\s*\:\s*\d+', line: '"max_active_downloading": 30', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"share_ratio_limit\"\s*\:\s*[\d\.]+', line: '"share_ratio_limit": 2.0', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"stop_seed_at_ratio\"\s*\:\s*\d+', line: '"stop_seed_at_ratio": true', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"stop_seed_ratio\"\s*\:\s*[\d\.]+', line: '"stop_seed_ratio": 2.0', path: "/home/docker/docker_data/deluge/config/core.conf"}
       - { regexp: '\"enabled_plugins\"[:\s]+\[.*]', line: '"enabled_plugins": ["Label", "Execute"]', path: "/home/docker/docker_data/deluge/config/core.conf"}
      

    - name: Start deluge
      docker_container:
        name: deluge
        state: started
        restart: yes
      become: yes
      when: not deluge_web_conf.stat.exists



    - name: Set URL base on configs
      replace:
        regexp: "{{ item.regexp }}"
        replace: "{{ item.line }}"
        path: "{{ item.path }}"
      with_items:
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/lidarr</UrlBase>", path: "/home/docker/docker_data/lidarr/config/config.xml"}
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/prowlarr</UrlBase>", path: "/home/docker/docker_data/prowlarr/config/config.xml"}
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/sonarr</UrlBase>", path: "/home/docker/docker_data/sonarr/config/config.xml"}
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/radarr</UrlBase>", path: "/home/docker/docker_data/radarr/config/config.xml"}
       - { regexp: '\<UrlBase\>(.+)?\<\/UrlBase\>', line: "  <UrlBase>/readarr</UrlBase>", path: "/home/docker/docker_data/readarr/config.xml"}
       - { regexp: 'base_url.+\=(.+)*', line: "base_url = /bazarr", path: "/home/docker/docker_data/bazarr/config/config/config.ini"}
       - { regexp: '"BasePathOverride"(\s+)?\:\s+[^,\r\n]+', line: '"BasePathOverride": "/jackett"', path: "/home/docker/docker_data/jackett/config/Jackett/ServerConfig.json"}
       - { regexp: '"base":\s+".+"', line: '  "base" : "/deluge"', path: "/home/docker/docker_data/deluge/config/web.conf"}
      register: url_base_output



    - name: Set API Key to single key
      replace:
        regexp: "{{ item.regexp }}"
        path: "{{ item.path }}"
        replace: "{{ item.line }}"
      with_items:
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/lidarr/config/config.xml"}
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/prowlarr/config/config.xml"}
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/sonarr/config/config.xml"}
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/radarr/config/config.xml"}
        - { regexp: '<ApiKey>[a-zA-Z0-9]+<\/ApiKey>', line: "  <ApiKey>{{ vm_vars.api_key }}</ApiKey>", path: "/home/docker/docker_data/readarr/config.xml"}
        - { regexp: 'apikey[\s\=]*[a-zA-Z0-9]*', line: "apikey = {{ vm_vars.api_key }}", path: "/home/docker/docker_data/bazarr/config/config/config.ini"}
        - { regexp: '"APIKey"\s*\:\s*"[a-zA-Z0-9]*"', line: '"APIKey" : "{{ vm_vars.api_key }}"', path: "/home/docker/docker_data/jackett/config/Jackett/ServerConfig.json"}
      register: api_change_output

    - name: Set Ombi API key (script creation)
      copy: 
        dest: "/tmp/ombi.sql"
        content: |
          update GlobalSettings set Content = '{"BaseUrl":"/ombi","CollectAnalyticData":true,"Wizard":true,"ApiKey":"{{ vm_vars.api_key }}","DoNotSendNotificationsForAutoApprove":false,"HideRequestsUsers":false,"DisableHealthChecks":false,"DefaultLanguageCode":"en","AutoDeleteAvailableRequests":false,"AutoDeleteAfterDays":0,"Branch":0,"HasMigratedOldTvDbData":true,"Set":false,"Id":1}' where Id = 1;
        mode: 0777

    - name: Set Ombi API key (insert stage)
      shell : "cat /tmp/ombi.sql |sqlite3 /home/docker/docker_data/ombi/config/OmbiSettings.db"

    - name: Generate Deluge web.conf
      set_fact:
        deluge_web_conf_content: '
        {
    "file": 2,
    "format": 1
}{
      "base" : "/deluge",
    "cert": "ssl/daemon.cert",
    "default_daemon": "",
    "enabled_plugins": [],
    "first_login": false,
    "https": false,
    "interface": "0.0.0.0",
    "language": "",
    "pkey": "ssl/daemon.pkey",
    "port": 8112,
    "pwd_salt": "c26ab3bbd8b137f99cd83c2c1c0963bcc1a35cad",
    "pwd_sha1": "2ce1a410bcdcc53064129b6d950f2e9fee4edc1e",
    "session_timeout": 3600,
    "show_session_speed": false,
    "show_sidebar": true,
    "sidebar_multiple_filters": true,
    "sidebar_show_zero": false,
    "theme": "gray"
}'
      when: not deluge_web_conf.stat.exists

 
    - name: Restart deluge, allow web.conf generation
      copy:
        dest: /home/docker/docker_data/deluge/config/web.conf
        content: "{{ deluge_web_conf_content }}"
        
      become: yes
      when: not deluge_web_conf.stat.exists

    - name: Restart certain containers if containers API, URL base or other params have changed
      docker_container:
        name: "{{ item }}"
        state: started
        restart: yes
      with_items: ["lidarr", "sonarr", "radarr", "bazarr", "readarr", "jackett", "deluge", "ombi", "prowlarr"]
      when: url_base_output.changed or api_change_output.changed
    

    - name: Template homer dashboard
      template:
        src: ../data/homer/homer.j2
        dest: /home/docker/docker_data/homer/config.yml
        mode: '0777'

    - name: Set homer permissions
      file:
        path: /home/docker/docker_data/homer/
        mode: '0777'
        recurse: yes

    - name: Set permissions (dirs)
      file:
        path: "{{ item.path }}"
        recurse: yes
        owner: "{{ item.owner }}"
        group: "{{ item.group }}"
        mode: "{{ item.mode }}"
      become: yes
      with_items:
       - { path: "{{ vm_vars.nas.storage_path }}", owner: media, group: media, mode: '0744' }
       - { path: "/home/docker/docker_data/", owner: media, group: media, mode: '0744' }
       - { path: "/home/docker/docker_data/homer", owner: media, group: media, mode: '0777'}
      register: final_permissions_dir

    - name: Set permissions (files)
      file:
        path: "{{ item.path }}"
        owner: "{{ item.owner }}"
        group: "{{ item.group }}"
        mode: "{{ item.mode }}"
      become: yes
      with_items:
       - { path: "/home/docker/docker_data/traefik/acme.json", owner: media, group: media, mode: '0600' }
      register: final_permissions_files


    - name: Start docker containers
      shell: "docker start $(docker ps -a -q)"

    - name: Wait for return code
      uri:
        url: "{{ traefik_default_scheme }}://{{ ansible_default_ipv4.address }}:{{ traefik_default_port }}/{{ item }}"
        status_code: 200
        validate_certs: false
      register: result
      until: result.status == 200
      retries: 60
      delay: 1
      with_items:
       - "sonarr"
       - "lidarr"
       - "radarr"


    - name: Set configurator fact base
      set_fact:
        cf_string: "python3 configure_apps.py -i {{ ansible_default_ipv4.address }} -p {{ traefik_default_port }} -a {{ vm_vars.api_key }} -s {{ traefik_default_scheme }}"

    - name: Add optional vars
      set_fact: 
        cf_string: "{{ cf_string + ' '  + item.key + ' ' + item.value }}"
      when: item != None
      with_items:
       - {key: "--open-subtitles-username", value: "{{ vm_vars.nas.open_subtitles_username | quote }}"}
       - {key: "--open-subtitles-password", value: "{{ vm_vars.nas.open_subtitles_password | quote }}"}
       - {key: "--plex-username", value: "{{ vm_vars.plex_username | quote }}"}
       - {key: "--plex-password", value: "{{ vm_vars.plex_password | quote }}"}
       - {key: "--app-username", value: "{{ vm_vars.local_username | quote }}"}
       - {key: "--app-password", value: "{{ vm_vars.local_password | quote }}"}

    - name: debug
      debug:
        msg: "{{ cf_string }}"


    - name: Run configurator (with opensubtitles support)
      command: "{{ cf_string }}"
      delegate_to: localhost
      args:
        chdir: scripts
      become: no
      register: configurator_w_support
      failed_when: "'success' not in configurator_w_support.stdout"
      

    - name: Enable services
      systemd:
        name: "{{ item }}"
        enabled: yes
        state: started
      with_items:
       - "avahi-daemon"


    - name: Restart all containers
      shell: docker restart $(docker ps -q)
      when: restart is defined


    - name: Connect tailscale
      command: "tailscale up --authkey {{ vm_vars.tailscale_auth_key }}"
      when: vm_vars.tailscale_auth_key is defined



     